package require tcltest

::tcltest::configure {*}$argv

::tcltest::testConstraint skip 0
::tcltest::testConstraint noskip 1
foreach unit {
    commands_constrain commands_convDateFmt commands_segment commands_stringNormalize

    row_to_array row_to_vars count_rows get_column compare_columns handle_empties

    write_table

    presentation_rows presentation_columns presentation_lookupColumn

    utils_anon utils_cols utils_getFirstLine utils_dbjoin utils_getdiag
    utils_dayDistance utils_round utils_serialCompareEqual
    utils_serialCompareEqualDecimal utils_serialCompareEmpty utils_yearDistance
    utils_getdiag_a
    
    result_intersect result_except result_range result_order_by result_select
    
} {
    ::tcltest::testConstraint $unit 1
}

if no {
    # superc by sql: presentation_get presentation_getRow presentation_getColumn
    presentation_toDOM presentation_asLoL presentation_toMatrix
    presentation_addHeader presentation_addRow presentation_set presentation_incr presentation_tally presentationwriter_write

    validator_oneOf validator_belongsTo validator_validate
    validator_notOneOf validator_matches validator_matchesOrIsEmpty
    logging_setLabel logging_addMessage
}

    package require sqlite3

::tcltest::loadTestedCommands

#source [file join H:/starkits csvops.kit]
namespace eval ::starkit [list variable topdir [file join .. topdir]]
::tcl::tm::path add [file join $starkit::topdir lib]
set auto_path [linsert $auto_path 0 [file join $starkit::topdir lib]]
set ::argv {} ; package require csvops

foreach file [glob -dir [file join .. topdir lib csvops ssrc] *.tcl] {
    source $file
}
if no {
namespace import ::msgcat::mc
::msgcat::mclocale sv
::msgcat::mcload [file join $::starkit::topdir msgs]
#::msgcat::mcload [file join $::starkit::topdir .. msgs]
}

# NOTE viewFile suppresses ending newline

# Features (mostly) replaced by sql application
::tcltest::test all-the-sql-1.0 {} -setup {
    set db [DB new]
    set res {}
} -body {
    set res {}
} -cleanup {
    $db destroy
} -result {}

# Interface to sql
::tcltest::test sql-methods-1.0 {} -setup {
    ::tcltest::makeFile "foo;bar;baz\n0;foo;ab\n1;snarf;cd\n2;blue;ef" a.csv
    set db [DB new]
    $db readTable t1 [file join [::tcltest::configure -tmpdir] a.csv]
    set res {}
} -body {
    # SELECT * FROM t1;
    lappend res [$db select t1]
    # SELECT foo, bar FROM t1;
    lappend res [$db select t1 foo bar]
    set res
} -cleanup {
    $db destroy
} -result {{0 foo ab 1 snarf cd 2 blue ef} {0 foo 1 snarf 2 blue}}

# db borrowed from https://www.w3schools.com/sql
::tcltest::makeFile [join [list \
{CustomerID;CustomerName;ContactName;Address;City;PostalCode;Country} \
{1;Alfreds Futterkiste;Maria Anders;Obere Str. 57;Berlin;12209;Germany} \
{2;Ana Trujillo Emparedados y helados;Ana Trujillo;Avda. de la Constitución 2222;México D.F.;05021;Mexico} \
{3;Antonio Moreno Taquería;Antonio Moreno;Mataderos 2312;México D.F.;05023;Mexico} \
{4;Around the Horn;Thomas Hardy;120 Hanover Sq.;London;WA1 1DP;UK} \
{5;Berglunds snabbköp;Christina Berglund;Berguvsvägen 8;Luleå;S-958 22;Sweden}] \n] a.csv
::tcltest::makeFile [join [list \
{CustomerID;CustomerName;ContactName;Address;City;PostalCode;Country} \
{89;White Clover Markets;Karl Jablonski;305 - 14th Ave. S. Suite 3B;Seattle;98128;USA} \
{90;Wilman Kala;Matti Karttunen;Keskuskatu 45;Helsinki;21240;Finland} \
{91;Wolski;Zbyszek;ul. Filtrowa 68;Walla;01-012;Poland}] \n] b.csv
::tcltest::makeFile [join [list \
{OrderID;CustomerID;OrderDate} \
{10308;2;1996-09-18} \
{10309;4;1996-09-19} \
{10310;77;1996-09-20}] \n] c.csv
::tcltest::makeFile [join [list \
{SupplierID;SupplierName;ContactName;Address;City;PostalCode;Country} \
{1;Exotic Liquid;Charlotte Cooper;49 Gilbert St.;London;EC1 4SD;UK} \
{2;New Orleans Cajun Delights;Shelley Burke;P.O. Box 78934;New Orleans;70117;USA} \
{3;Grandma Kelly's Homestead;Regina Murphy;707 Oxford Rd.;Ann Arbor;48104;USA}] \n] d.csv

::tcltest::test sql-methods-1.1 {} -setup {
    set res {}
} -body {
    set db [DB new]
    $db readTable Customers [file join [::tcltest::configure -tmpdir] a.csv]
    # SELECT Country FROM Customers
    lappend res [$db select Customers Country]
    lappend res [$db eval {SELECT DISTINCT Country FROM Customers}]
    lappend res [$db eval {SELECT COUNT(DISTINCT Country) FROM Customers}]
    lappend res [$db eval {SELECT CustomerID FROM Customers WHERE Country='Mexico'}]
    lappend res [$db eval {SELECT CustomerID FROM Customers WHERE CustomerID=1}]
    lappend res [$db eval {SELECT CustomerID FROM Customers WHERE Country='Germany' AND City='Berlin'}]
    lappend res [$db eval {SELECT CustomerID FROM Customers WHERE City='Berlin' OR City='München'}]
    lappend res [$db eval {SELECT CustomerID FROM Customers WHERE NOT Country='Germany'}]
    lappend res [$db eval {SELECT CustomerID FROM Customers ORDER BY Country}]
    lappend res [$db eval {SELECT CustomerID FROM Customers ORDER BY Country DESC}]
    $db destroy
    set db [DB new]
    $db readTable Customers [file join [::tcltest::configure -tmpdir] b.csv]
    # INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)
    # VALUES ('Cardinal', 'Tom B. Erichsen', 'Skagen 21', 'Stavanger', '4006', 'Norway');
    set columns {CustomerName ContactName Address City PostalCode Country}
    set values  [split {Cardinal,Tom B. Erichsen,Skagen 21,Stavanger,4006,Norway} ,]
    $db insert Customers $columns $values
    lappend res [$db select Customers Country]
    set res
} -cleanup {
    catch {$db destroy}
} -result {{Germany Mexico Mexico UK Sweden} {Germany Mexico UK Sweden} 4 {2 3} 1 1 1 {2 3 4 5} {1 2 3 5 4} {4 5 2 3 1} {USA Finland Poland Norway}}

::tcltest::test sql-methods-1.2 {} -setup {
    set res {}
} -body {
    set db [DB new]
    $db readTable Customers [file join [::tcltest::configure -tmpdir] a.csv]
    $db readTable Orders [file join [::tcltest::configure -tmpdir] c.csv]
    lappend res [$db eval2 {
        SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
        FROM Orders
        INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID
    }]
    lappend res [$db eval2 {
        SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
        FROM Orders
        LEFT JOIN Customers ON Orders.CustomerID=Customers.CustomerID
    }]
    set res
} -cleanup {
    catch {$db destroy}
} -result {{* {OrderID CustomerName OrderDate} 0 {10308 {Ana Trujillo Emparedados y helados} 1996-09-18} 1 {10309 {Around the Horn} 1996-09-19}} {* {OrderID CustomerName OrderDate} 0 {10308 {Ana Trujillo Emparedados y helados} 1996-09-18} 1 {10309 {Around the Horn} 1996-09-19} 2 {10310 {} 1996-09-20}}}

::tcltest::test sql-methods-1.3 {} -setup {
    set res {}
} -body {
    set db [DB new]
    $db readTable Customers [file join [::tcltest::configure -tmpdir] a.csv]
    $db readTable Suppliers [file join [::tcltest::configure -tmpdir] d.csv]
    lappend res [$db eval {
        SELECT City FROM Customers
        UNION
        SELECT City FROM Suppliers
        ORDER BY City;
    }]
    lappend res [$db eval {
        SELECT City FROM Customers
        UNION ALL
        SELECT City FROM Suppliers
        ORDER BY City;
    }]
    set res
} -cleanup {
    catch {$db destroy}
} -result {{{Ann Arbor} Berlin London Luleå {México D.F.} {New Orleans}} {{Ann Arbor} Berlin London London Luleå {México D.F.} {México D.F.} {New Orleans}}}

::tcltest::test commands_constrain-1.0 {constrain:} -constraints {commands_constrain} -setup {
} -body {
    # decl: constrain {varName args}
    set a 17
    constrain a -integer 15 20
    set b 17
    constrain b -integer 20 25
    set c 17
    constrain c -integer 10 15
    set d 17
    constrain d -integer 10
    list $a $b $c $d
} -cleanup {
    unset a b c d
} -result {17 20 15 17}


::tcltest::test commands_convDateFmt-1.0 {convDateFmt: defaults} -constraints {commands_convDateFmt} -setup {
} -body {
    # decl: convDateFmt {varName args}
    set a 2013-06-25
    convDateFmt a
    set a
} -cleanup {
    unset a
} -result 13-06-25


::tcltest::test commands_convDateFmt-1.1 {convDateFmt: defaults} -constraints {commands_convDateFmt} -setup {
} -body {
    # decl: convDateFmt {varName args}
    set a 13-06-25
    convDateFmt a
    set a
} -cleanup {
    unset a
} -match glob -result {felaktigt datumformat f*r -from} -returnCodes error


::tcltest::test commands_convDateFmt-1.2 {convDateFmt: garbage output} -constraints {commands_convDateFmt} -setup {
} -body {
    # decl: convDateFmt {varName args}
    set a 2013-06-25
    convDateFmt a -to %f
    set a
} -cleanup {
    unset a
} -result %f


::tcltest::test commands_convDateFmt-1.3 {convDateFmt: } -constraints {commands_convDateFmt} -setup {
} -body {
    # decl: convDateFmt {varName args}
    set a 13-06-25
    convDateFmt a -from %y-%m-%d -to %Y=%m=%d
    set a
} -cleanup {
    unset a
} -result 2013=06=25


::tcltest::test commands_convDateFmt-1.4 {convDateFmt: } -constraints {commands_convDateFmt} -setup {
} -body {
    # decl: convDateFmt {varName args}
    set a {}
    convDateFmt a -default foobar
    set a
} -cleanup {
    unset a
} -result foobar


::tcltest::test commands_segment-1.0 {segment:} -constraints {commands_segment} -setup {
} -body {
    # decl: segment {varName args}
    set a 17
    segment a 15 20
    set b 17
    segment b 20 25
    set c 17
    segment c 10 15
    set d 17
    segment d 10
    list $a $b $c $d
} -cleanup {
    unset a b c d
} -result {16_20 0_20 16_ 11_}


::tcltest::test commands_stringNormalize-1.0 {stringNormalize:} -constraints {commands_stringNormalize} -setup {
} -body {
    # decl: stringNormalize {varName {ops trim}}
    set a { abc def  }
    stringNormalize a
    set b { abc def  }
    stringNormalize b toupper
    set c { abc def  }
    stringNormalize c {trim totitle}
    list $a $b $c
} -cleanup {
    unset a b c
} -result {{abc def} { ABC DEF  } {Abc def}}


::tcltest::test row_to_array-1.0 {get:} -constraints {row_to_array} -setup {
    ::tcltest::makeFile "1;a;\n2;b;29\n3;c;23" foobar.csv
    set r [DB new]
    $r makeTable t1 {foo bar baz} [$r read [file join [::tcltest::configure -tmpdir] foobar.csv]]
} -body {
    $r eval {SELECT * FROM t1 LIMIT 0,1} F continue
    $r eval {SELECT * FROM t1 LIMIT 1,1} G continue
    list $F(foo) $G(foo)
} -cleanup {
    $r destroy
    unset F
} -result {1 2}


::tcltest::test row_to_vars-1.1 {get:} -constraints {noskip row_to_vars} -setup {
    set p [DB new]
    $p makeTable t1 {a b c d} {{1 2 3 4} {5 6 7 8}}
    set res {}
} -body {
    $p eval {SELECT * FROM t1} {
        lappend res $c
    }
    set res
} -cleanup {
    $p destroy
} -result {3 7}


::tcltest::test count_rows-1.0 {rows:} -constraints {noskip count_rows} -setup {
    set r [DB new]
    $r makeTable t1 {a b c d} {{1 2 3 4} {5 6 7 8}}
} -body {
    $r eval {SELECT COUNT(*) FROM t1}
} -cleanup {
    $r destroy
} -result 2


::tcltest::test get_column-1.0 {getColumn:} -constraints {noskip get_column} -setup {
    set p [DB new]
    $p makeTable t1 {a b c d} {{1 2 3 4} {5 6 7 8}}
} -body {
    $p eval {SELECT c FROM t1}
} -cleanup {
    $p destroy
} -result {3 7}


::tcltest::test compare_columns-2.0 {getColumn: compare columns for equality} -constraints {compare_columns} -setup {
    ::tcltest::makeFile "1;a;\n2;b;29\n3;c;23" foobar.csv
    ::tcltest::makeFile "1;a;83\n2;b;29\n4;c;" bazqux.csv
    set r [DB new]
    $r makeTable t1 {foo bar baz} [$r read [file join [::tcltest::configure -tmpdir] foobar.csv]]
    $r makeTable t2 {foo bar baz} [$r read [file join [::tcltest::configure -tmpdir] bazqux.csv]]
} -body {
    set C [$r eval {SELECT foo FROM t1}]
    set D [$r eval {SELECT foo FROM t2}]
    set E [$r eval {SELECT bar FROM t1}]
    set F [$r eval {SELECT bar FROM t2}]
    list [expr {$C == $D}] [expr {$E == $F}]
} -cleanup {
    $r destroy
    unset C D E F
} -result {0 1}


::tcltest::test compare_columns-2.1 {getColumn: compare columns for numeric difference} -constraints {compare_columns} -setup {
    ::tcltest::makeFile "1;a;\n2;b;29\n3;c;23" foobar.csv
    ::tcltest::makeFile "1;a;83\n2;b;29\n4;c;" bazqux.csv
    set r [DB new]
    $r makeTable t1 {foo bar baz} [$r read [file join [::tcltest::configure -tmpdir] foobar.csv]]
    $r makeTable t2 {foo bar baz} [$r read [file join [::tcltest::configure -tmpdir] bazqux.csv]]
} -body {
    set C [$r eval {SELECT foo FROM t1}]
    set D [$r eval {SELECT foo FROM t2}]
    set s1 [::tcl::mathop::+ {*}$C]
    set s2 [::tcl::mathop::+ {*}$D]
    expr {$s2 - $s1}
} -cleanup {
    $r destroy
    unset C D s1 s2
} -result 1


::tcltest::test compare_columns-2.2 {getColumn: compare columns for numeric difference, with empty cells} -constraints {compare_columns} -setup {
    ::tcltest::makeFile "1;a;\n2;b;29\n3;c;23" foobar.csv
    ::tcltest::makeFile "1;a;83\n2;b;29\n4;c;" bazqux.csv
    set r [DB new]
    $r makeTable t1 {foo bar baz} [$r read [file join [::tcltest::configure -tmpdir] foobar.csv]]
    $r makeTable t2 {foo bar baz} [$r read [file join [::tcltest::configure -tmpdir] bazqux.csv]]
} -body {
    set s1 [$r eval {SELECT SUM(baz) FROM t1}]
    set s2 [$r eval {SELECT SUM(baz) FROM t2}]
    expr {int($s1 - $s2)}
} -cleanup {
    $r destroy
    unset s1 s2
} -result -60


::tcltest::test compare_columns-2.3 {getColumn: compare columns for numeric difference, decimal numbers} -constraints {compare_columns} -setup {
    ::tcltest::makeFile "1;a;;1,67\n2;b;29;2,05\n3;c;23;3" foobar.csv
    ::tcltest::makeFile "1;a;83;0,68\n2;b;29;4,12\n4;c;;1,05" bazqux.csv
    set r [DB new]
    $r makeTable t1 {foo bar baz qux} [$r read [file join [::tcltest::configure -tmpdir] foobar.csv]]
    $r makeTable t2 {foo bar baz qux} [$r read [file join [::tcltest::configure -tmpdir] bazqux.csv]]
} -body {
    set s1 [$r eval {SELECT SUM(qux) FROM t1}]
    set s2 [$r eval {SELECT SUM(qux) FROM t2}]
    expr {$s1 - $s2}
} -cleanup {
    $r destroy
    unset s1 s2
} -result 0.8700000000000001


::tcltest::test compare_columns-2.4 {getColumn: serial comparison for equality -- integer} -constraints {compare_columns} -setup {
    ::tcltest::makeFile "1;a;;1,67\n2;b;29;2,05\n3;c;23;3" foobar.csv
    ::tcltest::makeFile "1;a;83;0,68\n2;b;29;4,12\n4;c;;1,05" bazqux.csv
    set r [DB new]
    $r makeTable t1 {foo bar baz qux} [$r read [file join [::tcltest::configure -tmpdir] foobar.csv]]
    $r makeTable t2 {foo bar baz qux} [$r read [file join [::tcltest::configure -tmpdir] bazqux.csv]]
} -body {
    lmap s1 [$r eval {SELECT foo FROM t1}] s2 [$r eval {SELECT foo FROM t2}] {
        expr {$s1 eq $s2}
    }
} -cleanup {
    $r destroy
    unset s1 s2
} -result {1 1 0}


::tcltest::test compare_columns-2.5 {getColumn: serial comparison for equality -- string} -constraints {compare_columns} -setup {
    ::tcltest::makeFile "1;a;;1,67\n2;b;29;2,05\n3;c;23;3" foobar.csv
    ::tcltest::makeFile "1;a;83;0,68\n2;b;29;4,12\n4;c;;1,05" bazqux.csv
    set r [DB new]
    $r makeTable t1 {foo bar baz qux} [$r read [file join [::tcltest::configure -tmpdir] foobar.csv]]
    $r makeTable t2 {foo bar baz qux} [$r read [file join [::tcltest::configure -tmpdir] bazqux.csv]]
} -body {
    lmap s1 [$r eval {SELECT bar FROM t1}] s2 [$r eval {SELECT bar FROM t2}] {
        expr {$s1 eq $s2}
    }
} -cleanup {
    $r destroy
    unset s1 s2
} -result {1 1 1}


::tcltest::test compare_columns-2.6 {getColumn: serial comparison for equality -- decimal} -constraints {compare_columns} -setup {
    ::tcltest::makeFile "1;a;;1,67\n2;b;29;2,05\n3;c;23;1,0500" foobar.csv
    ::tcltest::makeFile "1;a;83;0,68\n2;b;29;4,12\n4;c;;1,05" bazqux.csv
    set r [DB new]
    $r makeTable t1 {foo bar baz qux} [$r read [file join [::tcltest::configure -tmpdir] foobar.csv]]
    $r makeTable t2 {foo bar baz qux} [$r read [file join [::tcltest::configure -tmpdir] bazqux.csv]]
} -body {
    lmap s1 [$r eval {SELECT qux FROM t1}] s2 [$r eval {SELECT qux FROM t2}] {
        expr {$s1 eq $s2}
    }
} -cleanup {
    $r destroy
    unset s1 s2
} -result {0 0 1}


::tcltest::test handle_empties-1.0 {getColumnValues: skip nulls} -constraints {noskip handle_empties} -setup {
    set p [DB new]
    $p makeTable t1 {a b c d} {{1 2 3 4} {5 6 {} 8}}
} -body {
    lmap val [$p eval {SELECT c FROM t1}] {if {$val ne {}} {set val} continue}
} -cleanup {
    $p destroy
} -result 3


::tcltest::test handle_empties-1.1 {getColumnValues: set nulls to 0} -constraints {noskip handle_empties} -setup {
    set p [DB new]
    $p makeTable t1 {a b c d} {{1 2 3 4} {5 6 {} 8}}
} -body {
    lmap val [$p eval {SELECT c FROM t1}] {if {$val ne {}} {set val} {expr 0}}
} -cleanup {
    $p destroy
} -result {3 0}


::tcltest::test presentation_addHeader-1.0 {addHeader:} -constraints {presentation_addHeader} -setup {
} -body {
    # decl: addHeader {_label args}
    set t [Presentation new]
    $t addHeader Foobar 1 2 3
    $t asLoL
} -cleanup {
    $t destroy
} -result {{Foobar 1 2 3}}


::tcltest::test presentation_addHeader-1.1 {addHeader:} -constraints {presentation_addHeader} -setup {
} -body {
    # decl: addHeader {_label args}
    set t [Presentation new]
    $t addHeader Foobar
    $t asLoL
} -cleanup {
    $t destroy
} -match glob -result {tabellen finns inte*} -returnCodes error


::tcltest::test presentation_addHeader-1.2 {addHeader:} -constraints {presentation_addHeader} -setup {
} -body {
    # decl: addHeader {_label args}
    set t [Presentation new]
    $t addHeader
    $t asLoL
} -cleanup {
    $t destroy
} -match glob -result {tabellen finns inte*} -returnCodes error


::tcltest::test presentation_addRow-1.0 {addRow:} -constraints {presentation_addRow} -setup {
} -body {
    # decl: addRow {key args}
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t asLoL
} -cleanup {
    $t destroy
} -result {{Foobar 1 2 3} {a 45 89 23}}


::tcltest::test presentation_addRow-1.1 {addRow:} -constraints {presentation_addRow} -setup {
} -body {
    # decl: addRow {key args}
    set t [Presentation new Foobar 1 2 3]
    $t addRow a
    $t asLoL
} -cleanup {
    $t destroy
} -result {{Foobar 1 2 3} {a {} {} {}}}


::tcltest::test presentation_get-1.0 {get:} -constraints {presentation_get} -setup {
    set d [DB new]
    $d makeTable t1 {id a b c} {{a 45 89 23}}
} -body {
    if no {
    # decl: get {row col}
    set t [Presentation new Foobar [$d eval2 {SELECT * FROM t1}]]
    $t get a b
    } else {
    $d eval {SELECT b FROM t1 WHERE id='a'}
    }
} -cleanup {
    $d destroy
    catch {$t destroy}
} -result 89


::tcltest::test presentation_get-1.1 {get:} -constraints {presentation_get} -setup {
    set d [DB new]
    $d makeTable t1 {id a b c} {{a 45 89 23}}
} -body {
    # decl: get {row col}
    set t [Presentation new Foobar [$d eval2 {SELECT * FROM t1}]]
    $t get a d
} -cleanup {
    $d destroy
    $t destroy
} -match glob -result {kolumnrubrik "d" saknas*} -returnCodes error


::tcltest::test presentation_set-1.0 {set:} -constraints {presentation_set} -setup {
} -body {
    # decl: set {row col val}
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t set a 2 33
    $t get a 2
} -cleanup {
    $t destroy
} -result 33


::tcltest::test presentation_incr-1.0 {incr:} -constraints {presentation_incr} -setup {
} -body {
    # decl: incr {row col args}
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t incr a 2
} -cleanup {
    $t destroy
} -result 90


::tcltest::test presentation_incr-1.1 {incr:} -constraints {presentation_incr} -setup {
} -body {
    # decl: incr {row col args}
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t incr a 2 15
} -cleanup {
    $t destroy
} -result 104


::tcltest::test presentation_incr-1.2 {incr:} -constraints {presentation_incr} -setup {
} -body {
    # decl: incr {row col args}
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t incr a 2 {}
} -cleanup {
    $t destroy
} -result 89


::tcltest::test presentation_getRow-1.0 {getRow:} -constraints {presentation_getRow} -setup {
    set d [DB new]
    $d makeTable t1 {id a b c} {{a 45 89 23} {b 89 37 82}}
} -body {
    if no {
    # decl: getRow row
    set t [Presentation new Foobar [$d eval2 {SELECT * FROM t1}]]
    $t getRow a
    } else {
    $d eval {SELECT * FROM t1 WHERE id='a'}
    }
} -cleanup {
    $d destroy
    catch {$t destroy}
} -result {a 45 89 23}


::tcltest::test presentation_getColumn-1.0 {getColumn:} -constraints {presentation_getColumn} -setup {
    set d [DB new]
    $d makeTable t1 {id a b c} {{a 45 89 23} {b 89 37 82}}
} -body {
    if no {
    # decl: getColumn col
    set t [Presentation new Foobar [$d eval2 {SELECT * FROM t1}]]
    $t getColumn b
    } else {
    $d eval {SELECT b FROM t1}
    }
} -cleanup {
    $d destroy
    catch {$t destroy}
} -result {89 37}


::tcltest::test presentation_rows-1.0 {rows:} -constraints {presentation_rows} -setup {
    set d [DB new]
    $d makeTable t1 {id a b c} {{a 45 89 23} {b 89 37 82}}
} -body {
    if no {
    # decl: rows {}
    set t [Presentation new Foobar [$d eval2 {SELECT * FROM t1}]]
    $t rows
    } else {
    $d eval {SELECT COUNT(*) FROM t1}
    }
} -cleanup {
    $d destroy
    catch {$t destroy}
} -result 2


::tcltest::test presentation_columns-1.0 {columns:} -constraints {presentation_columns} -setup {
    set d [DB new]
    $d makeTable t1 {id a b c} {{a 45 89 23} {b 89 37 82}}
} -body {
    if no {
    # decl: columns {}
    set t [Presentation new Foobar [$d eval2 {SELECT * FROM t1}]]
    $t columns
    } elseif no {
    # ... added in SQLite version 3.16.0 (2017-01-02). Prior versions of SQLite cannot use this feature.
    $d eval {select count(*) from pragma table_info('t1')}
    } else {
    llength [dict get [$d eval2 {select * from t1}] *]
    }
} -cleanup {
    $d destroy
    catch {$t destroy}
} -result 4


::tcltest::test presentation_toDOM-1.0 {toDOM:} -constraints {presentation_toDOM} -setup {
} -body {
    # decl: toDOM doc
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t addRow b 89 37 82
    set doc [dom createDocument html]
    set root [$doc documentElement]
    $root appendChild [$t toDOM $doc]
    $doc asHTML
} -cleanup {
    $t destroy
    $doc delete
} -result {<html><table>
<caption>Foobar</caption><tr>
<th></th><th>1</th><th>2</th><th>3</th>
</tr><tr>
<th>a</th><td>45</td><td>89</td><td>23</td>
</tr><tr>
<th>b</th><td>89</td><td>37</td><td>82</td>
</tr>
</table></html>}


::tcltest::test presentation_asLoL-1.0 {asLoL:} -constraints {presentation_asLoL} -setup {
} -body {
    # decl: asLoL {}
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t addRow b 89 37 82
    $t asLoL
} -cleanup {
    $t destroy
} -result {{Foobar 1 2 3} {a 45 89 23} {b 89 37 82}}


::tcltest::test presentation_toMatrix-1.0 {toMatrix:} -constraints {presentation_toMatrix} -setup {
} -body {
    # decl: toMatrix {}
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t addRow b 89 37 82
    set m [$t toMatrix [::struct::matrix]]
    $m get cell 3 2
} -cleanup {
    $t destroy
    $m destroy
} -result 82


::tcltest::test presentation_tally-1.0 {tally:} -constraints {presentation_tally} -setup {
    set d [DB new]
    $d makeTable t1 {a b c} {{1 2 3}}
} -body {
    # decl: tally args
    set t [Presentation new Foobar [$d eval2 {SELECT * FROM t1}]]
    $t tally foo 1
    $t tally bar 2
    $t tally baz 3
    $t makeDistribution value 0 -dictionary
    $t asLoL
} -cleanup {
    $d destroy
    $t destroy
} -result {{Foobar 1 2 3} {bar 0 1 0} {baz 0 0 1} {foo 1 0 0}}


::tcltest::test presentation_tally-1.1 {tally:} -constraints {presentation_tally} -setup {
} -body {
    # decl: tally args
    set t [Presentation new Foobar 1 2 3]
    $t tally foo 1
    $t tally bar 2
    $t tally baz 3
    $t makeDistribution value 2 -dictionary
    $t asLoL
} -cleanup {
    $t destroy
} -result {{Foobar 1 2 3} {bar 0 1 0} {baz 0 0 1}}


::tcltest::test presentation_tally-1.2 {tally:} -constraints {presentation_tally} -setup {
} -body {
    # decl: tally args
    set t [Presentation new Foobar 1]
    $t tally foo
    $t tally foo
    $t tally foo
    $t tally bar
    $t tally bar
    $t tally baz
    $t makeDistribution value 0 -integer -decreasing
    $t asLoL
} -cleanup {
    $t destroy
} -result {{Foobar 1} {foo 3} {bar 2} {baz 1}}


::tcltest::test presentation_tally-1.3 {tally:} -constraints {presentation_tally} -setup {
} -body {
    # decl: tally args
    set t [Presentation new Foobar 1]
    $t tally foo
    $t tally foo
    $t tally foo
    $t tally bar
    $t tally bar
    $t tally baz
    $t makeDistribution name 0 -dictionary
    $t asLoL
} -cleanup {
    $t destroy
} -result {{Foobar 1} {bar 2} {baz 1} {foo 3}}


::tcltest::test presentation_tally-1.4 {tally:} -constraints {presentation_tally} -setup {
} -body {
    # decl: tally args
    set t [Presentation new Foobar 1]
    $t tally foo
    $t tally foo
    $t tally foo
    $t tally bar
    $t tally bar
    $t tally baz
    $t makeDistribution name 2 -dictionary
    $t asLoL
} -cleanup {
    $t destroy
} -result {{Foobar 1} {bar 2} {baz 1}}


::tcltest::test presentation_lookupColumn-1.0 {} -constraints {presentation_lookupColumn} -setup {
    set d [DB new]
    $d makeTable t1 {a b c} {{1 2 3}}
} -body {
    if no {
    set t [Presentation new Foobar [$d eval2 {SELECT * FROM t1}]]
    $t lookupColumn b
    } else {
    $d eval {SELECT b FROM t1}
    }
} -cleanup {
    $d destroy
    catch {$t destroy}
} -result 2


::tcltest::test presentationwriter_write-1.0 {} -constraints {presentationwriter_write} -setup {
    ::tcltest::makeFile {} foo.csv
} -body {
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t addRow b 89 37 82
    set w [PresentationWriter new]
    $w write [file join [tcltest::temporaryDirectory] foo.csv] $t
    ::tcltest::viewFile [file join [tcltest::temporaryDirectory] foo.csv]
} -cleanup {
    $t destroy
} -result {Foobar;1;2;3
a;45;89;23
b;89;37;82}


::tcltest::test presentationwriter_write-1.0 {} -constraints {presentationwriter_write} -setup {
    ::tcltest::makeFile {} foo.html
} -body {
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t addRow b 89 37 82
    set w [PresentationWriter new]
    $w write [file join [tcltest::temporaryDirectory] foo.html] $t
    ::tcltest::viewFile [file join [tcltest::temporaryDirectory] foo.html]
} -cleanup {
    $t destroy
} -result {<html>
<head>
<link rel="stylesheet" type="text/css" href="csvops.css"><title>Utmatning skapad av csvops</title>
</head><body><table>
<caption>Foobar</caption><tr>
<th></th><th>1</th><th>2</th><th>3</th>
</tr><tr>
<th>a</th><td>45</td><td>89</td><td>23</td>
</tr><tr>
<th>b</th><td>89</td><td>37</td><td>82</td>
</tr>
</table></body>
</html>}


::tcltest::test utils_anon-1.0 {anon:} -constraints {utils_anon} -setup {
} -body {
    # decl: anon args
    set res {}
    lappend res [anon 6 2]
    lappend res [anon 2 6]
    lappend res [anon 4 4]
    lappend res [anon 2 6]
    set res
} -cleanup {
    unset res
} -result {1 2 3 2}


::tcltest::test utils_cols-1.0 {cols:} -constraints {utils_cols} -setup {
} -body {
    # decl: cols {fields headings}
    cols {c d g} {a b c d e f g h i j}
} -cleanup {
} -result {2 3 6}


::tcltest::test utils_cols-1.1 {cols:} -constraints {utils_cols} -setup {
} -body {
    # decl: cols {fields headings}
    cols {c d g} {}
} -cleanup {
} -match glob -result {ogiltigt f*ltnamn "c"} -returnCodes error


::tcltest::test utils_dayDistance-1.0 {dayDistance:} -constraints {utils_dayDistance} -setup {
} -body {
    # decl: dayDistance {varName date {format %y-%m-%d}}
    dayDistance 13-06-25 13-06-25
} -cleanup {
} -result 0


::tcltest::test utils_dayDistance-1.1 {dayDistance:} -constraints {utils_dayDistance} -setup {
} -body {
    # decl: dayDistance {varName date {format %y-%m-%d}}
    dayDistance 13-06-25 13-06-30
} -cleanup {
} -result 5


::tcltest::test utils_dayDistance-1.2 {dayDistance:} -constraints {utils_dayDistance} -setup {
} -body {
    # decl: dayDistance {varName date {format %y-%m-%d}}
    dayDistance 13-06-25 14-06-25
} -cleanup {
} -result 365


::tcltest::test utils_dayDistance-1.3 {dayDistance:} -constraints {utils_dayDistance} -setup {
} -body {
    # decl: dayDistance {varName date {format %y-%m-%d}}
    dayDistance 13-06-25 12-06-25
} -cleanup {
} -result -365


::tcltest::test utils_getFirstLine-1.0 {getFirstLine:} -constraints {utils_getFirstLine} -setup {
    ::tcltest::makeFile "foo bar\nbaz qux" foo.bar
} -body {
    # decl: getFirstLine filename
    getFirstLine [file join [::tcltest::configure -tmpdir] foo.bar]
} -cleanup {
} -result {foo bar}


::tcltest::test utils_getdiag-1.0 {getdiag:} -constraints {utils_getdiag} -setup {
} -body {
    # decl: getdiag ds
    getdiag saknas
} -cleanup {
} -result saknas


::tcltest::test utils_getdiag-1.1 {getdiag:} -constraints {utils_getdiag} -setup {
} -body {
    # decl: getdiag ds
    getdiag z
} -cleanup {
} -result z


::tcltest::test utils_getdiag-1.2 {getdiag:} -constraints {utils_getdiag} -setup {
} -body {
    # decl: getdiag ds
    getdiag annan
} -cleanup {
} -result annan


::tcltest::test utils_getdiag-1.3 {getdiag:} -constraints {utils_getdiag} -setup {
} -body {
    # decl: getdiag ds
    getdiag f6
} -cleanup {
} -result f6


::tcltest::test utils_getdiag-1.4 {getdiag:} -constraints {utils_getdiag} -setup {
} -body {
    # decl: getdiag ds
    getdiag {saknas z}
} -cleanup {
} -result z


::tcltest::test utils_getdiag-1.5 {getdiag:} -constraints {utils_getdiag} -setup {
} -body {
    # decl: getdiag ds
    getdiag {annan z}
} -cleanup {
} -result annan


::tcltest::test utils_getdiag-1.6 {getdiag:} -constraints {utils_getdiag} -setup {
} -body {
    # decl: getdiag ds
    getdiag {f6 z}
} -cleanup {
} -result f6


::tcltest::test utils_getdiag-1.7 {getdiag:} -constraints {utils_getdiag} -setup {
} -body {
    # decl: getdiag ds
    getdiag {saknas annan}
} -cleanup {
} -result annan


::tcltest::test utils_getdiag-1.8 {getdiag:} -constraints {utils_getdiag} -setup {
} -body {
    # decl: getdiag ds
    getdiag {z annan}
} -cleanup {
} -result annan


::tcltest::test utils_getdiag-1.9 {getdiag:} -constraints {utils_getdiag} -setup {
} -body {
    # decl: getdiag ds
    getdiag {f6 annan}
} -cleanup {
} -result f6


::tcltest::test utils_round-1.0 {round:} -constraints {utils_round} -setup {
} -body {
    # decl: round {varName sigdig decimals {decimalChar ,}}
    set x 1.75451658
    set a [round $x 6 2]
    set b [round $x 2 6]
    set c [round $x 4 4 &]
    list $a $b $c
} -cleanup {
    unset x a b c
} -result {1,75 1,800000 1&7550}


::tcltest::test utils_round-1.1 {round:} -constraints {utils_round} -setup {
} -body {
    # decl: round {varName sigdig decimals {decimalChar ,}}
    set x 1754516.58
    set a [round $x 6 2]
    set b [round $x 2 6]
    set c [round $x 4 4 &]
    list $a $b $c
} -cleanup {
    unset x a b c
} -result {1754520,00 1800000,000000 1755000&0000}


::tcltest::test utils_yearDistance-1.0 {yearDistance:} -constraints {utils_yearDistance} -setup {
} -body {
    # decl: yearDistance {year0 {year1 {}}}
    set a [yearDistance 2014 2012]
    set b [yearDistance 2014 2015]
    # TODO will have to be changed every year
    set c [yearDistance 2014]
    list $a $b $c
} -cleanup {
    unset a b c
} -result {-2 1 4}


::tcltest::test utils_getdiag_a-1.0 {getdiag_a:} -constraints {utils_getdiag_a} -setup {
} -body {
    getdiag_a {}
} -cleanup {
} -result annan


::tcltest::test utils_getdiag_a-1.1 {getdiag_a:} -constraints {utils_getdiag_a} -setup {
} -body {
    getdiag_a {foo bar baz}
} -cleanup {
} -result annan


::tcltest::test utils_getdiag_a-1.2 {getdiag_a:} -constraints {utils_getdiag_a} -setup {
} -body {
    getdiag_a {foo f7 bar baz}
} -cleanup {
} -result f7


::tcltest::test validator_validate-1.0 {validate:} -constraints {validator_validate} -setup {
    ::tcltest::makeFile {} validate-output
    set p [DB new]
    $p makeTable t1 {a b c d} {{1 2 3 4} {5 6 7 8}}
} -body {
    # decl: validate {clauses output}
    $p validate {
        F(c) one-of {1 2 3 4}
        F(c) not-one-of {1 2 3 4}
        F(c) matches {[1-4]}
    } [file join [::tcltest::configure -tmpdir] validate-output]
    ::tcltest::viewFile validate-output
} -cleanup {
    $p destroy
} -match glob -result {Rad 1: v*rde 3 (f*lt F(c)) *r en av {1 2 3 4}
Rad 2: v*rde 7 (f*lt F(c)) *r inte en av {1 2 3 4}
Rad 2: v*rde 7 (f*lt F(c)) matchar inte "\[1-4\]"}


::tcltest::test validator_validate-1.1 {validate:} -constraints {validator_validate} -setup {
    ::tcltest::makeFile {} validate-output
    set p [Reader new]
    set m [::struct::matrix]
    $m add columns 4
    $m add row {1 2 3 4}
    $m add row {5 6 7 8}
    $p fields {a b c d}
    $p import $m
} -body {
    # decl: validate {clauses output}
    $p validate {
        F(c) foobar {1 2 3 4}
    } [file join [::tcltest::configure -tmpdir] validate-output]
    ::tcltest::viewFile validate-output
} -cleanup {
    $p destroy
    unset m
} -match glob -result {ogiltig valideringsoperation "foobar"*} -returnCodes error


::tcltest::test validator_one-of-1.0 {one-of:} -constraints {validator_oneOf} -setup {
} -body {
    # decl: one-of {val validation}
    validator one-of 99 {98 99 100}
} -cleanup {
} -result {}


::tcltest::test validator_one-of-1.1 {one-of:} -constraints {validator_oneOf} -setup {
} -body {
    # decl: one-of {val validation}
    validator one-of 97 {98 99 100}
} -cleanup {
} -match glob -result {*r inte en av {98 99 100}}


::tcltest::test validator_not-one-of-1.0 {not-one-of:} -constraints {validator_notOneOf} -setup {
} -body {
    # decl: not-one-of {val validation}
    validator not-one-of a {b c d}
} -cleanup {
} -result {}


::tcltest::test validator_matches-1.0 {matches:} -constraints {validator_matches} -setup {
} -body {
    # decl: matches {val validation}
    validator matches foo {f([aou])\1}
} -cleanup {
} -result {}


::tcltest::test validator_matches-or-is-empty-1.0 {matches-or-is-empty:} -constraints {validator_matchesOrIsEmpty} -setup {
} -body {
    # decl: matches-or-is-empty {val validation}
    validator matches-or-is-empty xyz {...}
} -cleanup {
} -result {}


::tcltest::test validator_matches-or-is-empty-1.1 {matches-or-is-empty:} -constraints {validator_matchesOrIsEmpty} -setup {
} -body {
    # decl: matches-or-is-empty {val validation}
    validator matches-or-is-empty {} {...}
} -cleanup {
} -result {}


::tcltest::test validator_belongs-to-1.0 {belongs-to:} -constraints {validator_belongsTo} -setup {
    proc ::csvops::convert-foobar val {return xyz}
} -body {
    # decl: belongs-to {val validation}
} -cleanup {
    validator belongs-to x foobar
} -result {}

set STARKITS H:/starkits
set SANDBOX H:/code
if {![file exists $STARKITS]} {
    set STARKITS [file normalize [file join ~ starkits]]
    set SANDBOX [file normalize [file join ~ code]]
}

::tcltest::test logging_addMessage-1.0 {addMessage:} -constraints {logging_addMessage} -setup {
    ::tcltest::makeFile "0;foo\n1;snarf\n2;blue" a.csv
    ::csvops::log::reset
    set ::csvops::log::running 1
    set r [Reader new -fields {foo bar}]
} -body {
    $r read [file join [::tcltest::configure -tmpdir] a.csv]
    set ::csvops::log::messages
} -cleanup {
    $r destroy
} -match glob -result [format {Reader ::oo::Obj* skapad
Reader ::oo::Obj* l*ser in "%s/csvops/test/temp/a.csv"
Reader ::oo::Obj* 3 rader, 21 bytear inl*sta
} $SANDBOX]


set options(-separator) \;


::tcltest::test logging_addMessage-1.1 {addMessage:} -constraints {logging_addMessage} -setup {
    ::tcltest::makeFile {} w.csv
    set r [Reader new -fields {foo bar}]
    set w [Writer new -fields {foo bar}]
    ::tcltest::makeFile "0;foo\n1;snarf\n2;blue" a.csv
    ::csvops::log::reset
    set ::csvops::log::running 1
} -body {
    $r read [file join [::tcltest::configure -tmpdir] a.csv]
    $r get { $w put }
    $w write [file join [::tcltest::configure -tmpdir] w.csv]
    set ::csvops::log::messages
} -cleanup {
    $r destroy
    $w destroy
} -match glob -result [format {Reader ::oo::Obj* l*ser in "%1$s/csvops/test/temp/a.csv"
Reader ::oo::Obj* 3 rader, 21 bytear inl*sta
Writer ::oo::Obj* skriver filen "%1$s/csvops/test/temp/w.csv"
} $SANDBOX]


::tcltest::test logging_addMessage-1.2 {} -constraints {logging_addMessage} -setup {
    ::tcltest::makeFile {} foo.csv
    ::csvops::log::reset
    set ::csvops::log::running 1
} -body {
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t addRow b 89 37 82
    set w [PresentationWriter new]
    $w write [file join [tcltest::temporaryDirectory] foo.csv] $t
    set ::csvops::log::messages
} -cleanup {
    $t destroy
} -match glob -result [format {Presentation ::oo::Obj* skapad
PresentationWriter ::oo::Obj* skapad
PresentationWriter ::oo::Obj* skriver filen "%s/csvops/test/temp/foo.csv" med formatet CSV
} $SANDBOX]


::tcltest::test logging_addMessage-1.3 {} -constraints {logging_addMessage} -setup {
    ::tcltest::makeFile {} foo.html
    ::csvops::log::reset
    set ::csvops::log::running 1
} -body {
    set t [Presentation new Foobar 1 2 3]
    $t addRow a 45 89 23
    $t addRow b 89 37 82
    set w [PresentationWriter new]
    $w write [file join [tcltest::temporaryDirectory] foo.html] $t
    set ::csvops::log::messages
} -cleanup {
    $t destroy
} -match glob -result [format {Presentation ::oo::Obj* skapad
PresentationWriter ::oo::Obj* skapad
PresentationWriter ::oo::Obj* skriver filen "%s/csvops/test/temp/foo.html" med formatet HTML
} $SANDBOX]


::tcltest::test logging_setLabel-1.0 {setLabel:} -constraints {logging_setLabel} -setup {
    ::tcltest::makeFile "0;foo\n1;snarf\n2;blue" a.csv
    ::csvops::log::reset
    set ::csvops::log::running 1
    set r [Reader new -fields {foo bar}]
} -body {
    $r read [file join [::tcltest::configure -tmpdir] a.csv]
    $r get {}
    lassign $::csvops::log::objects key lbl
    set tag [dict get $::csvops::log::labels $key]
    list $key $lbl $tag
} -cleanup {
    $r destroy
} -match glob -result {{Reader ::oo::Obj*} {bearbetar rad 3} loglbl1}


::tcltest::test logging_setLabel-1.1 {setLabel:} -constraints {logging_setLabel} -setup {
    set r [Reader new -fields {foo bar}]
    set w [Writer new -fields {foo bar}]
    ::tcltest::makeFile "0;foo\n1;snarf\n2;blue" a.csv
    ::csvops::log::reset
    set ::csvops::log::running 1
    ::tcltest::makeFile {} w.csv
} -body {
    $r read [file join [::tcltest::configure -tmpdir] a.csv]
    $r get { $w put }
    lassign [dict filter $::csvops::log::objects key Writer*] key lbl
    set tag [dict get $::csvops::log::labels $key]
    list $key $lbl $tag
} -cleanup {
    $r destroy
    $w destroy
} -match glob -result {{Writer ::oo::Obj*} {lagrar rad 3} loglbl2}


if no {
::Presentation destroy
foreach file [glob -dir [file join $starkit::topdir _src] *.tcl] {
    source $file
}
}


::tcltest::test result_intersect-1.0 {result_intersect:} -constraints {result_intersect} -setup {
    set r [DB new]
    $r makeTable t1 {a b c} {{1 2 3} {2 3 1} {3 1 2} {3 1 2}}
    $r makeTable t2 {a b c} {{4 5 6} {5 6 4} {4 5 6}}
} -body {
    dict values [$r eval2 {SELECT * FROM t1 INTERSECT SELECT * FROM t2}]
} -cleanup {
    $r destroy
} -result {}


::tcltest::test result_intersect-1.1 {result_intersect:} -constraints {result_intersect} -setup {
    set r [DB new]
    $r makeTable t1 {a b c} {{1 2 3} {2 3 1} {3 1 2} {3 1 2}}
    $r makeTable t2 {a b c} {{2 3 1} {2 3 1} {3 2 1}}
} -body {
    dict values [$r eval2 {SELECT * FROM t1 INTERSECT SELECT * FROM t2}]
} -cleanup {
    $r destroy
} -result {{a b c} {2 3 1}}


::tcltest::test result_except-1.0 {result_except:} -constraints {result_except} -setup {
    set r [DB new]
    $r makeTable t1 {a b c} {{1 2 3} {2 3 1} {3 1 2} {3 1 2}}
    $r makeTable t2 {a b c} {{4 5 6} {5 6 4} {4 5 6}}
} -body {
    dict values [$r eval2 {SELECT * FROM t1 EXCEPT SELECT * FROM t2}]
} -cleanup {
    $r destroy
} -result {{a b c} {1 2 3} {2 3 1} {3 1 2}}


::tcltest::test result_except-1.1 {result_except:} -constraints {result_except} -setup {
    set r [DB new]
    $r makeTable t1 {a b c} {{1 2 3} {2 3 1} {3 1 2} {3 1 2}}
    $r makeTable t2 {a b c} {{2 3 1} {2 3 1} {3 2 1}}
} -body {
    dict values [$r eval2 {SELECT * FROM t1 EXCEPT SELECT * FROM t2}]
} -cleanup {
    $r destroy
} -result {{a b c} {1 2 3} {3 1 2}}


::tcltest::test result_range-1.0 {result_range:} -constraints {result_range} -setup {
    set r [DB new]
    $r makeTable t1 {a b} {{1 2} {3 4} {5 6} {7 8} {9 0} {2 1} {4 3} {6 5} {8 7} {0 9}}
} -body {
    lrange [dict values [$r eval2 {SELECT * FROM t1 LIMIT 3}]] 1 end
} -cleanup {
    $r destroy
} -result {{1 2} {3 4} {5 6}}


::tcltest::test result_range-1.1 {result_range:} -constraints {result_range} -setup {
    set r [DB new]
    $r makeTable t1 {a b} {{1 2} {3 4} {5 6} {7 8} {9 0} {2 1} {4 3} {6 5} {8 7} {0 9}}
} -body {
    lrange [dict values [$r eval2 {SELECT * FROM t1 LIMIT 4, 4}]] 1 end
} -cleanup {
    $r destroy
} -result {{9 0} {2 1} {4 3} {6 5}}


::tcltest::test result_range-1.2 {result_range:} -constraints {result_range} -setup {
    set r [DB new]
    $r makeTable t1 {a b} {{1 2} {3 4} {5 6} {7 8} {9 0} {2 1} {4 3} {6 5} {8 7} {0 9}}
} -body {
    lrange [dict values [$r eval2 {SELECT * FROM t1 LIMIT 2, 99999999}]] 1 end
} -cleanup {
    $r destroy
} -result {{5 6} {7 8} {9 0} {2 1} {4 3} {6 5} {8 7} {0 9}}


::tcltest::test result_order_by-1.0 {result_order_by: (force text sorting)} -constraints {result_order_by} -setup {
    set r [DB new]
    $r makeTable t1 {{a text} b} {{2 a} {11 a} {1 b} {2 b} {11 A} {1 A}}
} -body {
    dict values [$r eval2 {SELECT * FROM t1 ORDER BY b COLLATE NOCASE ASC, a}]
} -cleanup {
    $r destroy
} -result {{a b} {1 A} {11 a} {11 A} {2 a} {1 b} {2 b}}


::tcltest::test result_order_by-1.1 {result_order_by:} -constraints {result_order_by} -setup {
    set r [DB new]
    $r makeTable t1 {a b} {{2 a} {11 a} {1 b} {2 b} {11 A} {1 A}}
} -body {
    dict values [$r eval2 {SELECT * FROM t1 ORDER BY b COLLATE NOCASE ASC, a}]
} -cleanup {
    $r destroy
} -result {{a b} {1 A} {2 a} {11 a} {11 A} {1 b} {2 b}}


::tcltest::test result_order_by-1.2 {result_order_by: (force text sorting)} -constraints {result_order_by} -setup {
    set r [DB new]
    $r makeTable t1 {{a text} b} {{2 a} {11 a} {1 b} {2 b} {11 A} {1 A}}
} -body {
    dict values [$r eval2 {SELECT * FROM t1 ORDER BY b, a}]
} -cleanup {
    $r destroy
} -result {{a b} {1 A} {11 A} {11 a} {2 a} {1 b} {2 b}}


::tcltest::test result_order_by-1.3 {result_order_by:} -constraints {result_order_by} -setup {
    set r [DB new]
    $r makeTable t1 {a b} {{2 a} {11 a} {1 b} {2 b} {11 A} {1 A}}
} -body {
    dict values [$r eval2 {SELECT * FROM t1 ORDER BY b, a}]
} -cleanup {
    $r destroy
} -result {{a b} {1 A} {11 A} {2 a} {11 a} {1 b} {2 b}}


::tcltest::test view_select-1.0 {view_select:} -constraints {view_select} -setup {
    set r [DB new]
    $r makeTable t1 {a b c d} {{1 2 3 4} {2 3 4 1} {3 4 1 2} {4 1 2 3}}
} -body {
    dict values [$r eval2 {SELECT a, b FROM t1}]
} -cleanup {
    $r destroy
} -result {{a b} {1 2} {2 3} {3 4} {4 1}}


::tcltest::test result_select-1.0 {result_select: -> copy into} -constraints {result_select} -setup {
    set r [DB new]
    $r makeTable t1 {a b c d} {{1 2 3 4} {2 3 4 1} {3 4 1 2} {4 1 2 3}}
    $r makeTable t2 {a b} {}
} -body {
    lrange [dict values [$r eval2 {INSERT INTO t2 SELECT a, b FROM t1 ; SELECT * FROM t2}]] 1 end
} -cleanup {
    $r destroy
} -result {{1 2} {2 3} {3 4} {4 1}}


::tcltest::test result_select-1.1 {result_select:} -constraints {result_select} -setup {
} -body {
    set r [DB new]
    $r makeTable t1 {a b c d} {{1 2 3 4} {2 3 4 1} {3 4 1 2} {4 1 2 3}}
    lrange [dict values [$r eval2 {SELECT a, b FROM t1 WHERE (a % 2 == 1)}]] 1 end
} -cleanup {
    $r destroy
} -result {{1 2} {3 4}}


    ::tcltest::makeFile "a;b;c;d\n1;2;3;4" a.csv
    ::tcltest::makeFile "5;6;7;8\n6;7;8;5" b.csv

::tcltest::test write_table-1.0 {write_table} -constraints write_table -setup {
    ::tcltest::makeFile "0;foo\n1;snarf\n2;blue" a.csv
    ::tcltest::makeFile "0;bagel\n1;snatz\n3;driver" b.csv
    set r [DB new]
    $r makeTable t1 {foo bar} [$r read [file join [::tcltest::configure -tmpdir] a.csv]]
    $r makeTable t2 {foo bar} [$r read [file join [::tcltest::configure -tmpdir] b.csv]]
    ::tcltest::makeFile {} output.csv
} -body {
    $r write t1 [file join [::tcltest::configure -tmpdir] output.csv]
    ::tcltest::viewFile output.csv
} -cleanup {
    $r destroy
} -result {foo;bar
0;foo
1;snarf
2;blue}


::tcltest::cleanupTests
